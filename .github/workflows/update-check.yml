name: Auto-update PKGBUILDs (nvchecker)

on:
  schedule:
    - cron: '0 6 * * *'
  workflow_dispatch:

jobs:
  nvchecker:
    runs-on: ubuntu-latest
    container:
      image: archlinux:latest
      options: --privileged

    steps:
      - name: Install dependencies
        run: |
          pacman -Syu --noconfirm
          pacman -S --noconfirm \
            base-devel \
            git \
            python \
            python-pip \
            github-cli \
            jq \
            curl \
            pacman-contrib
          pip install nvchecker --break-system-packages

          # Create a non-root user for updpkgsums/makepkg (refuses to run as root)
          useradd -m builduser
          echo "builduser ALL=(ALL) NOPASSWD: ALL" >> /etc/sudoers

      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          token: ${{ secrets.GH_PAT }}

      - name: Grant builduser workspace access
        run: |
          # updpkgsums needs write access to the package directory
          chown -R builduser:builduser "$GITHUB_WORKSPACE"
          # Also allow builduser to write to /tmp
          chmod 1777 /tmp

      - name: Configure git
        run: |
          git config --global --add safe.directory "$GITHUB_WORKSPACE"
          git config --global user.name "github-actions[bot]"
          git config --global user.email "github-actions[bot]@users.noreply.github.com"

      - name: Write nvchecker keyfile
        run: |
          cat > "$GITHUB_WORKSPACE/.nvchecker/keyfile.toml" <<EOF
          [keys]
          github = "${{ secrets.GH_PAT }}"
          EOF
        # The keyfile provides the GitHub token to avoid API rate limiting.
        # If GH_PAT is not set, nvchecker will still work but may hit rate limits
        # for repos with many packages. Alternatively set NVCHECKER_GITHUB_TOKEN env var.

      - name: Generate nvchecker.toml
        run: |
          cd "$GITHUB_WORKSPACE"
          python3 .nvchecker/generate-nvchecker-config.py \
            --src-dir src \
            --output .nvchecker/nvchecker.toml
          echo "=== Generated nvchecker.toml ==="
          cat .nvchecker/nvchecker.toml

      - name: Ensure oldver.json exists
        run: |
          if [ ! -f "$GITHUB_WORKSPACE/.nvchecker/oldver.json" ]; then
            echo "{}" > "$GITHUB_WORKSPACE/.nvchecker/oldver.json"
          fi

      - name: Run nvchecker
        run: |
          cd "$GITHUB_WORKSPACE"
          nvchecker -c .nvchecker/nvchecker.toml -l warning
          echo "=== Current versions detected ==="
          cat .nvchecker/newver.json

      - name: Ensure auto-update label exists
        env:
          GH_TOKEN: ${{ secrets.GH_PAT }}
        run: |
          gh label create "auto-update"             --description "Automated PKGBUILD update by nvchecker"             --color "0075ca"             --repo "$GITHUB_REPOSITORY" 2>/dev/null || true

      - name: Update PKGBUILDs and open PRs
        env:
          GH_TOKEN: ${{ secrets.GH_PAT }}
        run: |
          cd "$GITHUB_WORKSPACE"

          OUTDATED=$(python3 - <<'PYEOF'
          import json

          def load_verfile(path):
              with open(path) as f:
                  data = json.load(f)
              # nvchecker v2 wraps versions in {"version": 2, "data": {...}}
              if isinstance(data, dict) and "data" in data and "version" in data:
                  return {pkg: info["version"] for pkg, info in data["data"].items()}
              # flat format {"pkg": "ver"}
              return data

          old = load_verfile(".nvchecker/oldver.json")
          new = load_verfile(".nvchecker/newver.json")

          for pkg, new_ver in new.items():
              old_ver = old.get(pkg, "")
              if old_ver != new_ver:
                  print(f"{pkg}|{old_ver}|{new_ver}")
          PYEOF
          )

          if [ -z "$OUTDATED" ]; then
            echo "All packages are up to date."
            exit 0
          fi

          echo "=== Packages with updates ==="
          echo "$OUTDATED"

          echo "$OUTDATED" | while IFS='|' read -r PKG_NAME OLD_VER NEW_VER; do
            echo ""
            echo "────────────────────────────────"
            echo "Processing: $PKG_NAME  ($OLD_VER -> $NEW_VER)"
            echo "────────────────────────────────"

            # Strip leading 'v' from version -- pkgver in Arch must not start with 'v'
            NEW_VER="${NEW_VER#v}"
            OLD_VER="${OLD_VER#v}"

            PKGBUILD=$(find "$GITHUB_WORKSPACE/src" -path "*/${PKG_NAME}/PKGBUILD" | head -1)
            if [ -z "$PKGBUILD" ]; then
              echo "  -> PKGBUILD not found, skipping."
              continue
            fi
            PKG_DIR=$(dirname "$PKGBUILD")

            IS_VCS=false
            if grep -qE '^pkgver\(\)' "$PKGBUILD" && grep -qE 'git\+https://' "$PKGBUILD"; then
              IS_VCS=true
            fi

            CURRENT_VER=$(grep -E '^pkgver=' "$PKGBUILD" | head -1 \
              | cut -d= -f2 | tr -d '"' | tr -d "'")
            CURRENT_REL=$(grep -E '^pkgrel=' "$PKGBUILD" | head -1 \
              | cut -d= -f2 | tr -d '"' | tr -d "'")

            if [ "$IS_VCS" = true ]; then
              # Clone the repo and compute pkgver() output directly
              echo "  -> Computing pkgver() for $PKG_NAME..."
              CLONE_DIR=$(sudo -u builduser mktemp -d)

              # Extract git URL from PKGBUILD source= line
              GIT_URL=$(grep -oP 'git\+https://[^"'"'"'\s)]+' "$PKGBUILD" | head -1 | sed 's/^git+//')

              if [ -z "$GIT_URL" ]; then
                echo "  -> Could not extract git URL, skipping."
                rm -rf "$CLONE_DIR"
                continue
              fi

              # Clone (shallow enough to get rev-list count + describe)
              if ! sudo -u builduser git clone --depth=50 "$GIT_URL" "$CLONE_DIR/$PKG_NAME" 2>&1; then
                echo "  -> Clone failed, skipping."
                rm -rf "$CLONE_DIR"
                continue
              fi

              # Extract pkgver() function body and run it
              PKGVER_FUNC=$(awk '/^pkgver\(\)/,/^}/' "$PKGBUILD" | tail -n +2 | head -n -1)
              COMPUTED_VER=$(cd "$CLONE_DIR/$PKG_NAME" && eval "$PKGVER_FUNC" 2>/dev/null | tr -d '\n')
              rm -rf "$CLONE_DIR"

              if [ -z "$COMPUTED_VER" ]; then
                echo "  -> Could not compute pkgver(), skipping."
                continue
              fi

              echo "  -> Computed pkgver: $CURRENT_VER -> $COMPUTED_VER"

              if [ "$COMPUTED_VER" = "$CURRENT_VER" ]; then
                echo "  -> pkgver unchanged ($CURRENT_VER), skipping."
                continue
              fi

              NEW_REL=1
              BRANCH_NAME="auto-update/${PKG_NAME}-${COMPUTED_VER}"
            else
              NEW_REL=1
              BRANCH_NAME="auto-update/${PKG_NAME}-${NEW_VER}"
            fi

            if git ls-remote --exit-code origin "refs/heads/$BRANCH_NAME" > /dev/null 2>&1; then
              echo "  -> Branch already exists, skipping."
              continue
            fi

            # Check if an open PR already exists for this package
            EXISTING_PR=$(gh pr list \
              --state open \
              --label "auto-update" \
              --search "auto-update($PKG_NAME)" \
              --json title \
              --jq ".[].title" \
              | grep -F "auto-update($PKG_NAME)" || true)
            if [ -n "$EXISTING_PR" ]; then
              echo "  -> Open PR already exists for $PKG_NAME, skipping."
              continue
            fi

            git checkout main
            git checkout -b "$BRANCH_NAME"

            PR_BODY_FILE=$(mktemp)

            if [ "$IS_VCS" = true ]; then
              sed -i "s/^pkgver=.*/pkgver=${COMPUTED_VER}/" "$PKGBUILD"
              sed -i "s/^pkgrel=.*/pkgrel=${NEW_REL}/" "$PKGBUILD"

              COMMIT_MSG="auto-update($PKG_NAME): ${CURRENT_VER} -> ${COMPUTED_VER}"
              PR_TITLE="auto-update($PKG_NAME): ${CURRENT_VER} -> ${COMPUTED_VER}"

              cat > "$PR_BODY_FILE" << PREOF
          ## Automated PKGBUILD update

          **Package:** ${PKG_NAME} (VCS package)
          **Previous pkgver:** ${CURRENT_VER}
          **New pkgver:** ${COMPUTED_VER}
          **pkgrel reset to:** 1

          pkgver computed by running the pkgver() function against the latest upstream commit.

          ---
          *Automatically generated by the nvchecker workflow.*
          PREOF

            else
              sed -i "s/^pkgver=.*/pkgver=${NEW_VER}/" "$PKGBUILD"
              sed -i "s/^pkgrel=.*/pkgrel=${NEW_REL}/" "$PKGBUILD"

              echo "  -> Regenerating checksums with updpkgsums..."
              cd "$PKG_DIR"
              # makepkg refuses to run as root - use the builduser created at setup
              if ! sudo -u builduser updpkgsums 2>&1; then
                echo "  -> ERROR: updpkgsums failed for $PKG_NAME — skipping PR."
                cd "$GITHUB_WORKSPACE"
                git checkout -- "$PKGBUILD"
                git checkout main
                git branch -D "$BRANCH_NAME" 2>/dev/null || true
                continue
              fi
              cd "$GITHUB_WORKSPACE"

              COMMIT_MSG="auto-update($PKG_NAME): ${OLD_VER} -> ${NEW_VER}"
              PR_TITLE="auto-update($PKG_NAME): ${OLD_VER} -> ${NEW_VER}"

              cat > "$PR_BODY_FILE" << PREOF
          ## Automated PKGBUILD update

          **Package:** ${PKG_NAME}
          **Previous version:** ${OLD_VER}
          **New version:** ${NEW_VER}
          **pkgrel reset to:** 1

          Checksums regenerated with updpkgsums (covers sha512sums, sha512sums_x86_64, sha512sums_aarch64).

          Please verify before merging:
          - [ ] Package builds correctly with the new version
          - [ ] No breaking changes in the upstream release notes
          - [ ] Checksums match the downloaded sources

          ---
          *Automatically generated by the nvchecker workflow.*
          PREOF
            fi

            git add "$PKG_DIR/PKGBUILD"
            if git diff --cached --quiet; then
              echo "  -> No changes to commit (updpkgsums failed), skipping PR."
              git checkout main
              git branch -D "$BRANCH_NAME" 2>/dev/null || true
              continue
            fi
            git commit -m "$COMMIT_MSG"
            git push origin "$BRANCH_NAME"

            gh pr create \
              --title "$PR_TITLE" \
              --body-file "$PR_BODY_FILE" \
              --base main \
              --head "$BRANCH_NAME" \
              --label "auto-update"

            rm -f "$PR_BODY_FILE"
            echo "  -> PR opened: $PR_TITLE"
          done

      - name: Save version state
        run: |
          cd "$GITHUB_WORKSPACE"
          git checkout main

          # Flatten nvchecker v2 envelope to simple {"pkg": "ver"} for oldver.json
          python3 - <<'PYEOF'
          import json
          with open(".nvchecker/newver.json") as f:
              data = json.load(f)
          if isinstance(data, dict) and "data" in data and "version" in data:
              flat = {pkg: info["version"] for pkg, info in data["data"].items()}
          else:
              flat = data
          with open(".nvchecker/oldver.json", "w") as f:
              json.dump(flat, f, indent=2)
          PYEOF

          rm -f .nvchecker/keyfile.toml
          if git diff --quiet .nvchecker/oldver.json; then
            echo "No version state change to commit."
          else
            git add .nvchecker/oldver.json
            git commit -m "chore(nvchecker): update oldver.json [skip ci]"
            git push origin main
          fi
