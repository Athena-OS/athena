name: System Installation Testing

on:
  workflow_dispatch:
  schedule:
    - cron: '0 17 */1 * *'

jobs:
  # Matrix Job for GNOME, BSPWM, KDE, and Nix
  installation-testing:
    runs-on: ubuntu-latest
    container:
      image: athenaos/base-devel:latest
      options: --privileged  # Needed for hwclock

    strategy:
      fail-fast: false  # Ensure all matrix jobs continue even if one fails
      matrix:
        config_installer:
          - { desktop: "gnome", displaymanager: "gdm", theme: "temple", terminal: "gnome terminal", shell: "fish", browser: "firefox", job_name: "Arch-based Install Test (GNOME)", config_file: "arch.json", installer: "aegis-arch" }
          - { desktop: "kde plasma", displaymanager: "lightdm neon", theme: "akame", terminal: "alacritty", shell: "zsh", browser: "brave", job_name: "Arch-based Install Test (KDE)", config_file: "arch.json", installer: "aegis-arch" }
          - { desktop: "xfce refined", displaymanager: "sddm", theme: "samurai", terminal: "xfce", shell: "bash", browser: "brave", job_name: "Arch-based Install Test (XFCE Refined)", config_file: "arch.json", installer: "aegis-arch" }
          - { desktop: "xfce picom", displaymanager: "sddm", theme: "graphite", terminal: "xfce", shell: "zsh", browser: "firefox", job_name: "Arch-based Install Test (XFCE Picom)", config_file: "arch.json", installer: "aegis-arch" }
          - { desktop: "mate", displaymanager: "gdm", theme: "hackthebox", terminal: "cool retro term", shell: "fish", browser: "firefox", job_name: "Arch-based Install Test (MATE)", config_file: "arch.json", installer: "aegis-arch" }
          - { desktop: "cinnamon", displaymanager: "gdm", theme: "sweet", terminal: "konsole", shell: "zsh", browser: "brave", job_name: "Arch-based Install Test (Cinnamon)", config_file: "arch.json", installer: "aegis-arch" }
          - { desktop: "bspwm", displaymanager: "gdm", terminal: "kitty", browser: "brave", job_name: "Arch-based Install Test (BSPWM)", config_file: "arch.json", installer: "aegis-arch" }
          - { desktop: "hyprland", displaymanager: "sddm", terminal: "foot", browser: "firefox", job_name: "Arch-based Install Test (Hyprland)", config_file: "arch.json", installer: "aegis-arch" }
          - { desktop: "gnome", displaymanager: "gdm", theme: "temple", terminal: "kitty", shell: "fish", browser: "firefox", job_name: "Nix-based Install Test", config_file: "nix.json", installer: "aegis-nix" }

    name: ${{ matrix.config_installer.job_name }}  # Dynamically assign the job name based on the matrix

    steps:
      - name: Install dependencies
        run: pacman -Syyu --noconfirm aegis grub mkinitcpio jq

      - name: Retrieve install configuration
        run: curl -O https://raw.githubusercontent.com/Athena-OS/athena/refs/heads/main/tests/${{ matrix.config_installer.config_file }}

      - name: Modify install configuration
        run: |
          ROOT_DEVICE=$(mount | grep "^/dev" | awk '{print $1}')
          # Sometimes GitHub-hosted runners could use sda disk to host their files and other times sdb. 
          if [[ "$ROOT_DEVICE" == *"sda"* ]]; then
              echo "Root device is on sda. Using sdb for test operations."
              TARGET_DISK="/dev/sdb"
          elif [[ "$ROOT_DEVICE" == *"sdb"* ]]; then
              echo "Root device is on sdb. Using sda for test operations."
              TARGET_DISK="/dev/sda"
          else
              echo "Root device is not sda or sdb. Unable to determine free disk."
              exit 1
          fi
          echo "TARGET_DISK=$TARGET_DISK" >> $GITHUB_ENV  # Set environment variable
          #lsblk $TARGET_DISK
          #fdisk -l $TARGET_DISK
          #mount
          #ls -la /mnt
          #ls -la /root
          #ls -la /tmp
          #ls -la /
          #mount ${TARGET_DISK}1 /mnt
          #ls -la /mnt
          #swapon --show
          #sudo swapoff /mnt/swapfile
          #swapon --show
          #rm -rf /mnt/*
          #ls -la /mnt
          #umount ${TARGET_DISK}1
          #parted -s $TARGET_DISK -- mklabel msdos
          #wipefs $TARGET_DISK
          #parted $TARGET_DISK align-check optimal 1
          #parted -s $TARGET_DISK -- mkpart primary ext4 1MiB 512MiB align optimal
          #parted -s $TARGET_DISK -- set 1 boot on
          #parted -s $TARGET_DISK -- mkpart primary btrfs 512MiB 100% align optimal
          #mkfs.ext4 -F ${TARGET_DISK}1
          #mkfs.btrfs -L athenaos -f ${TARGET_DISK}2
          #lsblk
          #fdisk -l $TARGET_DISK
          jq --arg target_disk "$TARGET_DISK" \
             --arg desktop "${{ matrix.config_installer.desktop }}" \
             --arg displaymanager "${{ matrix.config_installer.displaymanager }}" \
             --arg theme "${{ matrix.config_installer.theme || '' }}" \
             --arg terminal "${{ matrix.config_installer.terminal || '' }}" \
             --arg shell "${{ matrix.config_installer.shell || '' }}" \
             --arg browser "${{ matrix.config_installer.browser || '' }}" \
             '.partition.device = $target_disk | .partition.mode = "EraseDisk" | .bootloader.location = $target_disk | .desktop = $desktop | .displaymanager = $displaymanager | .theme = $theme | .terminal = $terminal | .shell = $shell | .browser = $browser' \
             ${{ matrix.config_installer.config_file }} > modified_${{ matrix.config_installer.config_file }}
          mv modified_${{ matrix.config_installer.config_file }} ${{ matrix.config_installer.config_file }}
        
      - name: Run the installer
        run: ${{ matrix.config_installer.installer }} config ${{ matrix.config_installer.config_file }}

  # Final job to send summary to webhook
  notify-result:
    runs-on: ubuntu-latest
    needs: installation-testing  # Wait until all matrix jobs complete
    if: always()  # Ensures this job runs even if any job fails or is canceled
    steps:
      - name: Generate Job Results Summary
        id: generate_summary
        run: |
          summary="Job Results:"
          # Convert the entire 'needs' context to JSON
          job_data=$(echo '${{ toJSON(needs) }}' | jq .)

          # Loop over each job and collect the results
          for job_name in $(echo "$job_data" | jq -r 'keys[]'); do
            job_result=$(echo "$job_data" | jq -r --arg job "$job_name" '.[$job].result')
            summary="$summary\n$job_name: $job_result"
          done

          # Output the summary to be used in later steps
          echo "$summary"
          echo "::set-output name=job-summary::$summary"

      - name: Send a request to webhook
        run: |
          curl -H "Content-Type: application/json" -d '{
            "embeds": [{
              "type": "rich",
              "title": "Workflow Actions",
              "thumbnail": {
                "url": "https://athenaos.org/_astro/athena-chibi.C4AxdAFD_Z1ifHWb.webp"
              },
              "author": {
                "name": "${{ github.actor }}",
                "url": "https://github.com/${{ github.actor }}",
                "icon_url": "https://avatars.githubusercontent.com/u/${{ github.actor_id }}?v=4"
              }
            }],
            "username": "Athena Git Ninja",
            "content": "Athena Installation Test\nBranch: ${{ github.ref }} \nCommit Hash: ${{ github.sha }}\n\n${{ steps.generate_summary.outputs.job-summary }}"
          }' ${{ secrets.WEBHOOK_URL }}
