name: System Installation Testing

on:
  workflow_dispatch:
  schedule:
    - cron: '0 17 */1 * *'

jobs:
  # Matrix Job for GNOME, BSPWM, KDE, and Nix
  installation-testing:
    runs-on: ubuntu-latest
    container:
      image: athenaos/base-devel:latest
      options: --privileged  # Needed for hwclock

    strategy:
      fail-fast: false  # Ensure all matrix jobs continue even if one fails
      matrix:
        config_installer:
          - { base: "Athena Arch", design: "temple", desktop: "gnome", display_manager: "astronaut", hostname: "athenaos", keyboard_layout: "us", locale: "en_US.UTF-8 UTF-8", root_passwd_hash: "$y$j9T$PvxwcqCC6Hdvd2Ordjyou.$YUqNgUIkMsI9FKtr7DwpO/d9ZKmQmgMMnD9EbPC5sH7", timezone: "Europe/Rome", username: "athena", password_hash: "$y$j9T$PvxwcqCC6Hdvd2Ordjyou.$YUqNgUIkMsI9FKtr7DwpO/d9ZKmQmgMMnD9EbPC5sH7", shell: "fish", job_name: "Arch-based Install Test (GNOME)"}
          - { base: "Athena Nix", design: "temple", desktop: "gnome", display_manager: "astronaut", hostname: "athenaos", keyboard_layout: "us", locale: "en_US.UTF-8 UTF-8", root_passwd_hash: "$y$j9T$PvxwcqCC6Hdvd2Ordjyou.$YUqNgUIkMsI9FKtr7DwpO/d9ZKmQmgMMnD9EbPC5sH7", timezone: "Europe/Rome", username: "athena", password_hash: "$y$j9T$PvxwcqCC6Hdvd2Ordjyou.$YUqNgUIkMsI9FKtr7DwpO/d9ZKmQmgMMnD9EbPC5sH7", shell: "zsh", job_name: "Nix-based Install Test (GNOME)"}

    name: ${{ matrix.config_installer.job_name }}  # Dynamically assign the job name based on the matrix

    steps:
      - name: Maximize build space
        uses: easimon/maximize-build-space@master
        with:
          root-reserve-mb: 512
          swap-size-mb: 1024
          remove-dotnet: 'true'
          remove-android: 'true'
          remove-haskell: 'true'
          remove-codeql: 'true'

      - name: Install dependencies
        run: pacman -Syyu --noconfirm aegis grub mkinitcpio jq multipath-tools

      - name: Retrieve install configuration
        run: |
          curl -O https://raw.githubusercontent.com/Athena-OS/athena/refs/heads/main/tests/system.json
          curl -O https://raw.githubusercontent.com/Athena-OS/athena/refs/heads/main/tests/drives.json

      - name: Modify install configuration
        run: |
          df -h
          dd if=/dev/zero of=virtual_disk.img bs=1M count=20480  # Create a 20GB disk image
          parted -s virtual_disk.img mklabel gpt
          parted -s virtual_disk.img mkpart primary fat32 1MiB 1024MiB
          parted -s virtual_disk.img mkpart primary fat32 1024MiB 1536MiB
          parted -s virtual_disk.img mkpart primary btrfs 1536MiB 100%
          parted -s virtual_disk.img set 1 bios_grub on # GitHub runners are not UEFI
          losetup -fP virtual_disk.img
          LOOP_DEV=$(losetup -j virtual_disk.img | cut -d':' -f1)
          ln -s $LOOP_DEV /dev/mapper/${LOOP_DEV#/dev/} # Aegis expects that the disk and its partitions are in the same directory
          kpartx -av $LOOP_DEV # Create partitions in /dev/mapper and map them correctly and making kernel aware
          TARGET_DISK="/dev/mapper/${LOOP_DEV#/dev/}"

          # Note: GitHub runners are not UEFI. I use EFI partition but it won't be used. It is still ok since this workflow is used just to test the system installation
          jq --arg d "$TARGET_DISK" '
            .drives.device = $d
            | .drives.content.type = "gpt"
            | .drives.content.partitions = [
                {action:"modify", blockdevice:($d+"p1"), end:"2099199", filesystem:"fat32", flags:["boot"], label:"XBOOTLDR", mountpoint:"/boot", sectors:2097152, size:"1024M", start:"2048", type:"filesystem"},
                {action:"modify", blockdevice:($d+"p2"), end:"3147775", filesystem:"fat32", flags:["esp"], label:"EFI", mountpoint:"/efi", sectors:1048576, size:"512M", start:"2099200", type:"filesystem"},
                {action:"modify", blockdevice:($d+"p3"), end:"41943039", filesystem:"btrfs", flags:[], label:"ROOT", mountpoint:"/", sectors:38795264, size:"18.5G", start:"3147776", type:"filesystem"}
              ]
          ' drives.json > drives.json.tmp && mv drives.json.tmp drives.json
      
          # ---- Update system.json with all fields from the matrix ----
          jq \
            --arg base             "${{ matrix.config_installer.base }}" \
            --arg design           "${{ matrix.config_installer.design }}" \
            --arg desktop          "${{ matrix.config_installer.desktop }}" \
            --arg display_manager  "${{ matrix.config_installer.display_manager }}" \
            --arg hostname         "${{ matrix.config_installer.hostname }}" \
            --arg keyboard_layout  "${{ matrix.config_installer.keyboard_layout }}" \
            --arg locale           "${{ matrix.config_installer.locale }}" \
            --arg root_hash        "${{ matrix.config_installer.root_passwd_hash }}" \
            --arg timezone         "${{ matrix.config_installer.timezone }}" \
            --arg username         "${{ matrix.config_installer.username }}" \
            --arg user_hash        "${{ matrix.config_installer.password_hash }}" \
            --arg shell            "${{ matrix.config_installer.shell }}" \
            '
            .config.base               = $base
            | .config.design           = $design
            | .config.desktop_environment = $desktop
            | .config.display_manager  = $display_manager
            | .config.hostname         = $hostname
            | .config.keyboard_layout  = $keyboard_layout
            | .config.locale           = $locale
            | .config.root_passwd_hash = $root_hash
            | .config.timezone         = $timezone
            # Ensure there is at least one user entry, then fill it
            | (.config.users |= (if (.|length)>0 then . else [ {} ] end))
            | .config.users[0].username      = $username
            | .config.users[0].password_hash = $user_hash
            | .config.users[0].shell         = $shell
            | (.config.users[0].groups //= ["wheel"])
            ' system.json > system.json.tmp && mv system.json.tmp system.json

      - name: Run the installer
        run: aegis --system-file ./system.json --drives-file ./drives.json

  # Final job to send summary to webhook
  notify-result:
    runs-on: ubuntu-latest
    needs: installation-testing  # Wait until all matrix jobs complete
    if: always()  # Ensures this job runs even if any job fails or is canceled
    steps:
      - name: Generate Job Results Summary
        id: generate_summary
        run: |
          summary="Job Results:"
          # Convert the entire 'needs' context to JSON
          job_data=$(echo '${{ toJSON(needs) }}' | jq .)

          # Loop over each job and collect the results
          for job_name in $(echo "$job_data" | jq -r 'keys[]'); do
            job_result=$(echo "$job_data" | jq -r --arg job "$job_name" '.[$job].result')
            summary="$summary\n$job_name: $job_result"
          done

          # Output the summary to be used in later steps
          echo "$summary"
          echo "::set-output name=job-summary::$summary"

      - name: Send a request to webhook
        run: |
          curl -H "Content-Type: application/json" -d '{
            "embeds": [{
              "type": "rich",
              "title": "Workflow Actions",
              "thumbnail": {
                "url": "https://athenaos.org/_astro/athena-chibi.C4AxdAFD_Z1ifHWb.webp"
              },
              "author": {
                "name": "${{ github.actor }}",
                "url": "https://github.com/${{ github.actor }}",
                "icon_url": "https://avatars.githubusercontent.com/u/${{ github.actor_id }}?v=4"
              }
            }],
            "username": "Athena Git Ninja",
            "content": "Athena Installation Test\nBranch: ${{ github.ref }} \nCommit Hash: ${{ github.sha }}\n\n${{ steps.generate_summary.outputs.job-summary }}"
          }' ${{ secrets.WEBHOOK_URL }}
