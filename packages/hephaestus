#!/usr/bin/env bash

makepkg_settings() {
    if [[ "$buildcores" ]]; then
        ncores=$coresnum
    else
        ncores=$(nproc)
    fi
    if [ $ncores != 1 ]
    then
        echo "$ncores cores available."
        echo "Changing the makeflags to $ncores cores."
        echo "Changing the compression settings for $ncores cores."
    else
        echo "$ncores core available."
        echo "Changing the makeflags to $ncores core."
        echo "Changing the compression settings for $ncores core."
    fi
    sudo sed -i 's/#MAKEFLAGS=.*/MAKEFLAGS="-j'$ncores'"/g' /etc/makepkg.conf;
    sudo sed -i 's/COMPRESSXZ=(xz -c -z -)/COMPRESSXZ=(xz -c -T 0 -z -)/g' /etc/makepkg.conf
}

prebuild_command() {
    #* Run pre-build commands
    if [[ -n "$PRE_EXEC" ]]
    then
      echo "Run pre-build commands..."
      echo "${PRE_EXEC}"
      ${PRE_EXEC}
    fi
}

postbuild_command() {
    #* Run post-build commands
    if [[ -n "$POST_EXEC" ]]
    then
      echo "Run post-build commands..."
      echo "${POST_EXEC}"
      ${POST_EXEC}
    fi
}

# Function to find directories containing PKGBUILD files
find_pkgbuild_dirs() {
    local pkgbuild_paths=()
    local search_dir="/build/packages/"

    # If user input is provided, use it as package names to search for
    if [ $# -gt 0 ]; then
        # Loop through provided package names
        for pkg_name in "$@"; do
            # Use find to locate PKGBUILD files in subdirectories
            while IFS= read -r -d '' pkgbuild_path; do
                # Print the package name and PKGBUILD path
                pkgbuild_paths+=("$pkgbuild_path")
            done < <(find "$search_dir" -type d -name "$pkg_name" -exec find {} -type f -name PKGBUILD -print0 \;)
        done
    else
        # Use find to locate PKGBUILD files in subdirectories
        while IFS= read -r -d '' pkgbuild_path; do
            # Consider only packages not in 'broken' and 'old' directories
            if [[ ! $pkgbuild_path =~ "broken" && ! $pkgbuild_path =~ "old" ]]; then
                # Extract package name from PKGBUILD path
                pkgbuild_paths+=("$pkgbuild_path")
            fi
        done < <(find "$search_dir" -type f -name PKGBUILD -print0)
    fi

    # Return the array of PKGBUILD paths
    echo "${pkgbuild_paths[@]}"
}

# Function to build and sign packages
build_package() {
    pkg_dir=$1
    cpu_arch=$2
    src_dir=$3
    out_dir=$4

    echo -e "\nBuilding package in $pkg_dir..."
    cd $pkg_dir

    makepkg -do --noprepare

    pkgname=($(grep "^pkgname=" PKGBUILD | awk -F"=" '{print $2}' | sed -e 's/[\[('\'')]//g' -e 's/"//g'))
    pkgrel=$(grep "^pkgrel=" PKGBUILD | awk -F"=" '{split($2,a," ");gsub(/"/, "", a[1]);print a[1]}' | sed -e 's/^"\|'\''//g' -e 's/"\|'\''$//g')
    pkgepoch=$(grep "^epoch=" PKGBUILD | awk -F"=" '{split($2,a," ");gsub(/"/, "", a[1]);print a[1] ":"}' | sed -e 's/^"\|'\''//g' -e 's/"\|'\''$//g')
    arch=$(awk -v cpu_arch="$cpu_arch" -F"[' ]" '/^arch=\(/ { for (i=2; i<=NF; i++) if ($i == cpu_arch || $i == "any") print $i }' PKGBUILD)
    pkgver=$(grep "^pkgver=" PKGBUILD | awk -F"=" '{print $2}' | sed -e 's/^"\|'\''//g' -e 's/"\|'\''$//g')
    pkgfile=()
    for pname in "${pkgname[@]}"; do
        pkgfile+=("${pname}-${pkgepoch}${pkgver}-${pkgrel}-${arch}.pkg.tar.zst")
    done

    if [ ! -f "$out_dir/$pkgfile" ] || [[ "$overwrite" ]]; then
        if [ -f "build.sh" ]; then
            # Error handling to prevent running interruption
            ./build.sh || {
                >&2 echo "ERROR: Failed to execute build.sh in $pkg_dir"
                return 1
            }
        else
            updpkgsums
            # Error handling to prevent running interruption
            makepkg -f -src --noconfirm || {
                >&2 echo "ERROR: Failed to execute makepkg in $pkg_dir"
                return 1
            }
            sudo rm -rf src pkg
        fi

        sign_package

        # A PKGBUILD could contain more than one package (i.e., python- packages)
        for pfile in "${pkgfile[@]}"; do
            echo -e "Moving $pfile to $out_dir"
            cp -f $pfile* $out_dir
            rm -f $pfile*
        done
    else
        >&2 echo "$pkgfile already exists in $out_dir"
    fi
    cd $src_dir
}

sign_package() {
    #* If env $sign is false, do not sign packages
    if [[ "$sign" ]]
    then
        echo "Signing the package..."
        if id "builder" >/dev/null 2>&1; then
            user="builder"
        else
            user="$(whoami)"
        fi

        if [ -n "$passphrase" ]; then
            for pfile in "${pkgfile[@]}"; do
                echo "Creating $pfile.sig"
                echo $passphrase | sudo -E -u $user gpg --detach-sign --use-agent --pinentry-mode loopback --passphrase --passphrase-fd 0 --output $pfile.sig $pfile
            done
        else
            echo "Error: 'PASSPHRASE' environment variable not set."
            exit 1
        fi
    fi
}

printf '%b\n' "$(base64 -d <<<"H4sIAAAAAAAAA6VRWwqAMAz79xR+ahF3Am8yqAfp4W36Yn4IopGFJjbdxoiO7yCaRGaA2VfhJp5ckcg3/3wKGCJqN8BsLSm0yDx8DOC5N+wx8lk2g2Inl5G3PmX/XS1Zq72gYXWtK2Tkw+02cgeXsYVth++cnt9luH+imf0amqd/73cBIZJnZ/8BAAA=" | gunzip)" #User printf for colored output
echo
echo "The Athena OS CI/CD Builder"
echo

# Parse command-line options
while getopts "ac:dhrswx" opt; do
    case $opt in
        a)
            all=true
            ;;
        c)
            buildcores=true
            if [[ $OPTARG =~ ^[0-9]+$ ]]; then
                coresnum=$((OPTARG))
            else
                echo "Error: Number of cores must be a positive integer." >&2
                exit 1
            fi
            ;;
        d)
            db=true
            ;;
        h)
            echo "Usage: $0 [-a] [-c <ncores>] [-d] [-r] [-s] [-w] [-x] [package1 package2 ...]"
            echo
            echo "Options:"
            echo "-a     Build all packages."
            echo "-c     Set number of cores for building (maximum $(nproc))."
            echo "-d     Update the package repository database."
            echo "-h     Print this Help."
            echo "-r     Upload packages to the specified repository server. Use '-e SSH_SEC=' to specify the SSH secret object and '-e REPOSITORY_SERVER=' to define the target repository server as container environment variable arguments."
            echo "-s     Sign packages. Use '-e GPG_SEC' to specify the signing key secret object as container environment variable argument."
            echo "-w     Overwrite existing packages in the output directory."
            echo "-x     Search for the fastest mirrors."
            echo
            exit 0
            ;;
        r)
            rsync=true
            sshsec="$(cat /run/secrets/${SSH_SEC})"
            if [[ -z "$sshsec" || -z "${REPOSITORY_SERVER}" ]]; then
                if [[ -z "$sshsec" ]]; then
                    echo "Error -r argument: Missing 'SSH_SEC' environment variable passed as container argument."
                fi
                if [[ -z "${REPOSITORY_SERVER}" ]]; then
                    echo "Error -r argument: Missing 'REPOSITORY_SERVER' environment variable passed as container argument."
                fi
                exit 1
            fi
            ;;
        s)
            sign=true
            ;;
        w)
            overwrite=true
            ;;
        x)
            mirr=true
            ;;
        \?)
            echo "Invalid option: -$OPTARG" >&2
            exit 1
            ;;
    esac
done
shift $((OPTIND - 1))

# Import the signing key
passphrase="$(cat /run/secrets/${GPG_SEC})" # pass argument -e GPG_SEC= to the container program
if [ -z "$passphrase" ]; then
    echo "No secret found for GPG key object ${GPG_SEC}."
else
    echo -n "$passphrase"| gpg --batch --yes --passphrase-fd 0 --import /build/keydir/key.asc
fi

if [[ "$mirr" ]]
then
    sudo rate-mirrors --concurrency 40 --disable-comments --allow-root --save /etc/pacman.d/mirrorlist arch
    sudo rate-mirrors --concurrency 40 --disable-comments --allow-root --save /etc/pacman.d/chaotic-mirrorlist chaotic-aur
fi

# Need to sync Hephaestus with the updated repository
sudo pacman -Syy

# Set the CPU Architecture for packaging
cpu_arch="x86_64"
src_dir="$(pwd)"
out_dir="$(df -P /build/output | awk 'NR==2 {print $6}')"

makepkg_settings
prebuild_command

# Get user input if provided
if [ "$#" -gt 0 ]; then
    result=($(find_pkgbuild_dirs "$@"))
elif [[ "$all" ]]; then
    result=($(find_pkgbuild_dirs))
fi

# Print the result array
for path in "${result[@]}"; do
    echo "Found PKGBUILD: $path"
    # Build and sign packages
    build_package "$(dirname $path)" "$cpu_arch" "$src_dir" "$out_dir"
    echo
done

if [[ "$db" ]]
then
    echo "Invoking the key..."
    if id "builder" >/dev/null 2>&1; then
        user="builder"
    else
        user="$(whoami)"
    fi

    if [ -n "$passphrase" ]; then
        echo $passphrase | sudo -E -u $user gpg --detach-sign --use-agent --pinentry-mode loopback --passphrase --passphrase-fd 0
    else
        echo "Error: 'PASSPHRASE' environment variable not set."
        exit 1
    fi
    # rm $out_dir/athena.db* $out_dir/athena.files*
    # Note that if only one package fails to be processed (i.e., packages with 0 size), athena.db won't be created
    repo-add --verify --sign -R $out_dir/athena.db.tar.gz $out_dir/*.pkg.tar.zst
fi

if [[ -n "$rsync" && -n "$sshsec" && -n "${REPOSITORY_SERVER}" ]]; then
    sshpass -p "$sshsec" rsync -avzzlr --delete -e "ssh -p 1027 -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null" "$out_dir/" "${REPOSITORY_SERVER}"
fi

postbuild_command
