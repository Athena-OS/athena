--- samba-clean/libcli/auth/smbencrypt.c	2011-12-12 18:36:11.000000000 -0500
+++ samba/libcli/auth/smbencrypt.c	2012-07-07 23:37:26.069268333 -0400
@@ -45,6 +45,9 @@ void SMBencrypt_hash(const uint8_t lm_ha
 #endif
 }
 
+#define SMB_HASH_LM 1
+#define SMB_HASH_NTLM 2
+
 /*
    This implements the X/Open SMB password encryption
    It takes a password ('unix' string), a 8 byte "crypt key"
@@ -63,6 +66,61 @@ bool SMBencrypt(const char *passwd, cons
 	return ret;
 }
 
+/*
+   Support for using LM/NTLM hashes -- jmk@foofus.net 10/2006 
+   Greets: Foofus, Phenfen, Omi, Fizzgig, pMonkey
+*/
+// Tweaked to work with later version(s) of samba by Alva "Skip" Duckwall 
+void E_set_hash(const char *passwd, int type, unsigned char hash[16])
+{
+ uint l;
+ char p[1024];
+ int i, j;
+ char HexChar;
+ int HexValue;
+
+printf("%s\n",passwd); 
+////////
+// substitute hashes lm:nt (65 char)  / lm:nt::: (68 char)
+// lmlmlmlmlmlmlmlmlmlmlmlmlmlmlmlm:ntntntntntntntntntntntntntntntnt
+// based on the foofus samba patch by jmk 
+// Modified by Alva "Skip" Duckwall
+////////
+ if ( strlen(passwd) == 65  || strlen(passwd) == 68)
+  { strncpy (p,passwd,1023) ;} else
+ if ( (getenv("SMBHASH")) && (strlen(getenv("SMBHASH")) == 65 || strlen(getenv("SMBHASH")) == 65) )
+ {
+   strncpy(p, getenv("SMBHASH"),1023);
+ }
+   for (i=0; i<16; i++) {
+     HexValue = 0x0;
+     for (j=0; j<2; j++) {
+       if (type == SMB_HASH_LM)
+         HexChar = (char)p[2*i+j];
+       else
+         HexChar = (char)p[2*i+j+33];
+
+       if (HexChar > 0x39)
+         HexChar = HexChar | 0x20;  /* convert upper case to lower */
+
+       if (!(((HexChar >= 0x30) && (HexChar <= 0x39))||   /* 0 - 9 */
+          ((HexChar >= 0x61) && (HexChar <= 0x66)))) {    /* a - f */
+         fprintf(stderr, "Error invalid char (%c) for hash.\n", HexChar);
+         exit(1);
+       }
+
+       HexChar -= 0x30;
+       if (HexChar > 0x09)  /* HexChar is "a" - "f" */
+         HexChar -= 0x27;
+
+       HexValue = (HexValue << 4) | (char)HexChar;
+     }
+     hash[i] = (unsigned char)HexValue;
+   }
+
+}
+/* jmk */
+
 /**
  * Creates the MD4 Hash of the users password in NT UNICODE.
  * @param passwd password in 'unix' charset.
@@ -75,6 +133,12 @@ bool E_md4hash(const char *passwd, uint8
 	smb_ucs2_t *wpwd;
 	bool ret;
 
+        /* Support for using NTLM hashes -- jmk@foofus.net 10/2006 */
+        // Modified for 65/68 char passwords by Alva 'Skip' Duckwall
+	if ( getenv("SMBHASH") || strlen(passwd) == 65  || strlen(passwd) == 68) {
+		fprintf(stderr, "HASH PASS: Substituting user supplied NTLM HASH...\n");
+		E_set_hash(passwd,SMB_HASH_NTLM, p16);
+	} else { 
 	ret = push_ucs2_talloc(NULL, &wpwd, passwd, &len);
 	if (!ret || len < 2) {
 		/* We don't want to return fixed data, as most callers
@@ -87,6 +151,7 @@ bool E_md4hash(const char *passwd, uint8
 	mdfour(p16, (const uint8_t *)wpwd, len);
 
 	talloc_free(wpwd);
+        }
 	return true;
 }
 
@@ -100,9 +165,13 @@ bool E_md4hash(const char *passwd, uint8
 void E_md5hash(const uint8_t salt[16], const uint8_t nthash[16], uint8_t hash_out[16])
 {
 	struct MD5Context tctx;
+	uint8_t array[32];
+
+	memset(hash_out, '\0', 16);
+	memcpy(array, salt, 16);
+	memcpy(&array[16], nthash, 16);
 	MD5Init(&tctx);
-	MD5Update(&tctx, salt, 16);
-	MD5Update(&tctx, nthash, 16);
+	MD5Update(&tctx, array, 32);
 	MD5Final(hash_out, &tctx);
 }
 
@@ -116,39 +185,28 @@ void E_md5hash(const uint8_t salt[16], c
 
 bool E_deshash(const char *passwd, uint8_t p16[16])
 {
-	bool ret;
-	uint8_t dospwd[14];
-	TALLOC_CTX *frame = talloc_stackframe();
-
-	size_t converted_size;
-
-	char *tmpbuf;
-
-	ZERO_STRUCT(dospwd);
-
-	tmpbuf = strupper_talloc(frame, passwd);
-	if (tmpbuf == NULL) {
-		/* Too many callers don't check this result, we need to fill in the buffer with something */
-		strlcpy((char *)dospwd, passwd ? passwd : "", sizeof(dospwd));
-		E_P16(dospwd, p16);
-		talloc_free(frame);
-		return false;
-	}
-
+	bool ret = true;
+	char dospwd[256];
 	ZERO_STRUCT(dospwd);
 
-	ret = convert_string_error(CH_UNIX, CH_DOS, tmpbuf, strlen(tmpbuf), dospwd, sizeof(dospwd), &converted_size);
-	talloc_free(frame);
-
-	/* Only the first 14 chars are considered, password need not
-	 * be null terminated.  We do this in the error and success
-	 * case to avoid returning a fixed 'password' buffer, but
-	 * callers should not use it when E_deshash returns false */
+  /* Support for using LM hashes -- jmk@foofus.net 10/2006 */
+  // modified by Alva "Skip" Duckwall for 65/68 character hash passwords
+  if ( getenv("SMBHASH") || strlen(passwd) == 65  || strlen(passwd) == 68 ) {
+    fprintf(stderr, "HASH PASS: Substituting user supplied LM HASH...\n");
+    E_set_hash(passwd,SMB_HASH_LM, p16);
+  } else {
+	/* Password must be converted to DOS charset - null terminated, uppercase. */
+	push_string(dospwd, passwd, sizeof(dospwd), STR_ASCII|STR_UPPER|STR_TERMINATE);
 
+	/* Only the first 14 chars are considered, password need not be null terminated. */
 	E_P16((const uint8_t *)dospwd, p16);
 
-	ZERO_STRUCT(dospwd);
+	if (strlen(dospwd) > 14) {
+		ret = false;
+	}
 
+	ZERO_STRUCT(dospwd);
+       }
 	return ret;
 }
 
