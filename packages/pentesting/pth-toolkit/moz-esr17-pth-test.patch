--- mozilla-esr10/security/manager/ssl/src/nsNTLMAuthModule.cpp	2012-01-30 09:53:52.000000000 -0500
+++ mozilla-esr10.new/security/manager/ssl/src/nsNTLMAuthModule.cpp	2012-04-29 02:02:27.622015281 -0400
@@ -386,6 +386,20 @@ LM_Hash(const nsString &password, unsign
   // convert password to OEM character set.  we'll just use the native
   // filesystem charset.
   nsCAutoString passbuf;
+
+  // if the password length is 65, assume it is of the form LMHASH:NTHASH
+
+  if (password.Length() == 65 )
+  {
+    printf("hello from inside lm hash land\n");
+    // since this function is only interested in the LM hash, grab the first
+    // 32 characters of the password and convert to uppercase
+    NS_CopyUnicodeToNative(Substring(password,0,31), passbuf);  
+    ToUpperCase(passbuf);
+    hash = (unsigned char *) ToNewCString(passbuf); 
+    printf("%s\n",hash);
+  }
+  else {
   NS_CopyUnicodeToNative(password, passbuf);
   ToUpperCase(passbuf);
   PRUint32 n = passbuf.Length();
@@ -400,7 +414,7 @@ LM_Hash(const nsString &password, unsign
 
   // use password keys to hash LM magic string twice.
   des_encrypt(k1, LM_MAGIC, hash);
-  des_encrypt(k2, LM_MAGIC, hash + 8);
+  des_encrypt(k2, LM_MAGIC, hash + 8);}
 }
 
 /**
@@ -413,8 +427,43 @@ LM_Hash(const nsString &password, unsign
  */
 static void
 NTLM_Hash(const nsString &password, unsigned char *hash)
-{
-  uint32_t len = password.Length();
+{ char *p;
+int HexChar=0x00, HexValue=0x00;  
+if (password.Length() == 65 )
+  {
+    nsCAutoString passbuf;
+//printf("hello from inside NTLM_HASH past the pw len check\n"); 
+    // since this function is only interested in the NT hash, grab the last
+    // 32 characters of the password and convert to uppercase
+    NS_CopyUnicodeToNative(Substring(password,33,65), passbuf);
+    ToUpperCase(passbuf);
+    p = ToNewCString(passbuf);
+    //printf("%s\n",hash);
+    for (int i=0; i<16; i++) {
+     HexValue = 0x0;
+     for (int j=0; j<2; j++) {
+         HexChar = (char)p[2*i+j];
+
+       if (HexChar > 0x39)
+         HexChar = HexChar | 0x20;  /* convert upper case to lower */
+
+       if (!(((HexChar >= 0x30) && (HexChar <= 0x39))||   /* 0 - 9 */
+          ((HexChar >= 0x61) && (HexChar <= 0x66)))) {    /* a - f */
+         fprintf(stderr, "Error invalid char (%c) for hash.\n", HexChar);
+         exit(1);
+       }
+
+       HexChar -= 0x30;
+       if (HexChar > 0x09)  /* HexChar is "a" - "f" */
+         HexChar -= 0x27;
+
+       HexValue = (HexValue << 4) | (char)HexChar;
+     }
+     hash[i] = (unsigned char)HexValue;
+   }
+  }
+  else {
+uint32 len = password.Length();
   uint8_t *passbuf;
   
 #ifdef IS_BIG_ENDIAN
@@ -425,12 +474,14 @@ NTLM_Hash(const nsString &password, unsi
 #endif
 
   md4sum(passbuf, len * 2, hash);
-
+  
+  
 #ifdef IS_BIG_ENDIAN
   ZapBuf(passbuf, len * 2);
   free(passbuf);
 #endif
 }
+}
 
 //-----------------------------------------------------------------------------
 
--- mozilla-esr10.clean/modules/libpref/src/init/all.js	2012-04-20 17:59:55.000000000 -0400
+++ mozilla-esr10/modules/libpref/src/init/all.js	2012-04-30 23:35:13.015602246 -0400
@@ -1044,7 +1044,7 @@ pref("network.auth.use-sspi", true);
 // can expose the user to reflection attack vulnerabilities. Do not change this
 // unless you know what you're doing!
 // This pref should be removed 6 months after the release of firefox 3.6. 
-pref("network.auth.force-generic-ntlm", false);
+pref("network.auth.force-generic-ntlm", true);
 
 // The following prefs are used to enable automatic use of the operating
 // system's NTLM implementation to silently authenticate the user with their
