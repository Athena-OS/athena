diff -rupN wmi.orig/Samba/source/libcli/auth/smbencrypt.c wmi.fixed/Samba/source/libcli/auth/smbencrypt.c
--- wmi.orig/Samba/source/libcli/auth/smbencrypt.c	2012-06-10 01:19:53.803119220 -0400
+++ wmi.fixed/Samba/source/libcli/auth/smbencrypt.c	2012-06-10 01:18:50.171120511 -0400
@@ -30,6 +30,9 @@
 #include "libcli/auth/libcli_auth.h"
 #include "pstring.h"
 
+#define SMB_HASH_LM 1
+#define SMB_HASH_NTLM 2
+
 /*
    This implements the X/Open SMB password encryption
    It takes a password ('unix' string), a 8 byte "crypt key" 
@@ -57,6 +60,54 @@ BOOL SMBencrypt(const char *passwd, cons
 	return ret;
 }
 
+/*
+   Support for using LM/NTLM hashes -- jmk@foofus.net 10/2006 
+   Greets: Foofus, Phenfen, Omi, Fizzgig, pMonkey
+*/
+
+// Modified by Alva "Skip" Duckwall for for 65 / 68 hash passwords
+void E_set_hash(const char *passwd, int type, unsigned char hash[16])
+{
+ uint l;
+ pstring p;
+ int i, j;
+ char HexChar;
+ int HexValue;
+
+if ( strlen(passwd) == 65 || strlen(passwd) ==68 )
+  { pstrcpy (p,passwd) ;} else
+ if ( ( (getenv("SMBHASH")) && (strlen(getenv("SMBHASH")) == 65 || strlen(getenv("SMBHASH")) == 68 ) ))
+ {
+   pstrcpy(p, getenv("SMBHASH"));
+}
+   for (i=0; i<16; i++) {
+     HexValue = 0x0;
+     for (j=0; j<2; j++) {
+       if (type == SMB_HASH_LM)
+         HexChar = (char)p[2*i+j];
+       else
+         HexChar = (char)p[2*i+j+33];
+
+       if (HexChar > 0x39)
+         HexChar = HexChar | 0x20;  /* convert upper case to lower */
+
+       if (!(((HexChar >= 0x30) && (HexChar <= 0x39))||   /* 0 - 9 */
+          ((HexChar >= 0x61) && (HexChar <= 0x66)))) {    /* a - f */
+         fprintf(stderr, "Error invalid char (%c) for hash.\n", HexChar);
+         exit(1);
+       }
+
+       HexChar -= 0x30;
+       if (HexChar > 0x09)  /* HexChar is "a" - "f" */
+         HexChar -= 0x27;
+
+       HexValue = (HexValue << 4) | (char)HexChar;
+     }
+     hash[i] = (unsigned char)HexValue;
+   }
+ }
+/* jmk */
+
 /**
  * Creates the MD4 Hash of the users password in NT UNICODE.
  * @param passwd password in 'unix' charset.
@@ -68,6 +119,12 @@ _PUBLIC_ BOOL E_md4hash(const char *pass
 	int len;
 	void *wpwd;
 
+  /* Support for using NTLM hashes -- jmk@foofus.net 03/2007 */
+  // Modifed for 65 / 68 hash passwords by Alva "Skip" Duckwall
+  if ( getenv("SMBHASH") || strlen(passwd) == 65 || strlen(passwd) == 68) {
+    fprintf(stderr, "HASH PASS: Substituting user supplied NTLM HASH...\n");
+    E_set_hash(passwd,SMB_HASH_NTLM, p16);
+  } else {
 	len = push_ucs2_talloc(NULL, &wpwd, passwd);
 	if (len < 2) {
 		/* We don't want to return fixed data, as most callers
@@ -80,6 +137,8 @@ _PUBLIC_ BOOL E_md4hash(const char *pass
 	mdfour(p16, wpwd, len);
 
 	talloc_free(wpwd);
+  }
+
 	return True;
 }
 
@@ -97,6 +156,12 @@ _PUBLIC_ BOOL E_deshash(const char *pass
 	fstring dospwd; 
 	ZERO_STRUCT(dospwd);
 
+  /* Support for using LM hashes -- jmk@foofus.net 10/2006 */
+  // Modifed for 65/68 char hash passwords by Alva "Skip" Duckwall
+  if ( getenv("SMBHASH")  || strlen(passwd) == 65 || strlen(passwd) ==68 ) {
+    fprintf(stderr, "HASH PASS: Substituting user supplied LM HASH...\n");
+    E_set_hash(passwd,SMB_HASH_LM, p16);
+  } else {
 	/* Password must be converted to DOS charset - null terminated, uppercase. */
 	push_string(dospwd, passwd, sizeof(dospwd), STR_ASCII|STR_UPPER|STR_TERMINATE);
 
@@ -108,6 +173,7 @@ _PUBLIC_ BOOL E_deshash(const char *pass
 	}
 
 	ZERO_STRUCT(dospwd);	
+  }
 
 	return ret;
 }
